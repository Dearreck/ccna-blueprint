[
  {
    "id": "json_component_key_q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.7",
      "description_es": "Reconocer componentes de datos codificados en JSON",
      "description_en": "Recognize components of JSON-encoded data",
      "subtopic_id": "6.7",
      "subtopic_description": "JSON Components"
    },
    "question_es": "**Consulte la información.** ¿Qué se identifica con la palabra `\"switch\"` dentro de la línea 2 del esquema `JSON`?",
    "question_en": "**Refer to the exhibit.** What is identified by the word `\"switch\"` within line 2 of the `JSON` Schema?",
    "image": null,
    "code": "[\n  {\"switch\": \"3750\", \"port\": \"e2\"},\n  {\"router\": \"2951\", \"port\": \"e20\"},\n  {\"switch\": \"3750\", \"port\": \"e23\"}\n]",
    "options": [
      { "text_es": "Valor (`Value`)", "text_en": "Value", "isCorrect": false },
      { "text_es": "Objeto (`Object`)", "text_en": "Object", "isCorrect": false },
      { "text_es": "Clave (`Key`)", "text_en": "Key", "isCorrect": true },
      { "text_es": "Array", "text_en": "Array", "isCorrect": false }
    ],
    "explanation_es": "En `JSON`, los datos dentro de un objeto `{}` se organizan en pares de **clave-valor** con el formato `\"clave\": \"valor\"`. En la línea 2, `\"switch\"` es la **clave** (o nombre de la propiedad), y `\"3750\"` es el **valor** asociado a esa clave.",
    "explanation_en": "In `JSON`, data within an object `{}` is organized into **key-value** pairs with the format `\"key\": \"value\"`. On line 2, `\"switch\"` is the **key** (or property name), and `\"3750\"` is the **value** associated with that key."
  },
  {
    "id": "automation_outcome_q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.1",
      "description_es": "Explicar cómo la automatización impacta la gestión de redes",
      "description_en": "Explain how automation impacts network management",
      "subtopic_id": "6.1",
      "subtopic_description": "Impact of Automation"
    },
    "question_es": "¿Cuál es un resultado esperado cuando se implementa la **automatización** de la gestión de redes?",
    "question_en": "What is an expected outcome when network management **automation** is deployed?",
    "image": null,
    "code": null,
    "options": [
      { "text_es": "Las actualizaciones de software se realizan desde un **controlador central**.", "text_en": "Software upgrades are performed from a **central controller**.", "isCorrect": true },
      { "text_es": "Se necesitan aplicaciones personalizadas para configurar los dispositivos.", "text_en": "Custom applications are needed to configure network devices.", "isCorrect": false },
      { "text_es": "La complejidad aumenta cuando se agregan nuevas configuraciones.", "text_en": "Complexity increases when new device configurations are added.", "isCorrect": false },
      { "text_es": "Se debe utilizar un plano de gestión distribuido.", "text_en": "A distributed management plane must be used.", "isCorrect": false }
    ],
    "explanation_es": "Uno de los principales beneficios de la automatización es la **centralización de la gestión**. Esto permite a los administradores realizar tareas complejas y repetitivas, como las actualizaciones de software, de manera consistente y eficiente en múltiples dispositivos desde un **único punto de control**.",
    "explanation_en": "One of the primary benefits of automation is the **centralization of management**. This allows administrators to perform complex and repetitive tasks, such as software upgrades, consistently and efficiently across multiple devices from a **single point of control**."
  },
  {
    "id": "dna_center_vs_traditional_q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.2",
      "description_es": "Comparar redes tradicionales con redes basadas en controladores",
      "description_en": "Compare traditional networks with controller-based networking",
      "subtopic_id": "6.2",
      "subtopic_description": "Controller-based vs. Traditional Networking"
    },
    "question_es": "¿Qué diferencia la gestión de dispositivos habilitada por `Cisco DNA Center` de la gestión **tradicional** de dispositivos de campus?",
    "question_en": "What differentiates device management enabled by `Cisco DNA Center` from **traditional** campus device management?",
    "image": null,
    "code": null,
    "options": [
      { "text_es": "centralizada", "text_en": "centralized", "isCorrect": true },
      { "text_es": "orientada a la `CLI` del dispositivo", "text_en": "`CLI`-oriented device", "isCorrect": false },
      { "text_es": "manual dispositivo por dispositivo", "text_en": "device-by-device hands-on", "isCorrect": false },
      { "text_es": "por dispositivo", "text_en": "per-device", "isCorrect": false }
    ],
    "explanation_es": "La gestión **tradicional** implica configurar cada dispositivo de forma individual (por dispositivo, orientado a la `CLI`). `Cisco DNA Center` introduce un modelo de gestión **centralizado**, donde las políticas se definen en un controlador único que luego las despliega a todos los dispositivos.",
    "explanation_en": "**Traditional** management involves configuring each device individually (per-device, `CLI`-oriented). `Cisco DNA Center` introduces a **centralized** management model, where policies are defined on a single controller that then deploys them to all network devices."
  },
  {
    "id": "northbound_api_q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.3",
      "description_es": "Describir la arquitectura definida por software y basada en controladores",
      "description_en": "Describe controller-based, software defined architecture",
      "subtopic_id": "6.3.b",
      "subtopic_description": "Northbound and Southbound APIs"
    },
    "question_es": "¿Cuál es la función de una **API northbound**?",
    "question_en": "What is the function of a **northbound API**?",
    "image": null,
    "code": null,
    "options": [
      { "text_es": "Soporta el procesamiento distribuido para la configuración.", "text_en": "It supports distributed processing for configuration.", "isCorrect": false },
      { "text_es": "Se basa en el aprovisionamiento y configuración global.", "text_en": "It relies on global provisioning and configuration.", "isCorrect": false },
      { "text_es": "Actualiza el software y restaura archivos.", "text_en": "It upgrades software and restores files.", "isCorrect": false },
      { "text_es": "Proporciona una vía de comunicación entre un **controlador `SDN`** y las **aplicaciones de red**.", "text_en": "It provides a path between an **`SDN` controller** and **network applications**.", "isCorrect": true }
    ],
    "explanation_es": "En una arquitectura `SDN`, las **APIs northbound** ('hacia el norte') permiten que las **aplicaciones**, sistemas de orquestación y scripts se comuniquen con el **controlador de red** para solicitar servicios. Permiten la abstracción de la red, de modo que las aplicaciones no necesitan conocer los detalles de la infraestructura.",
    "explanation_en": "In an `SDN` architecture, **northbound APIs** ('upwards') allow **applications**, orchestration systems, and scripts to communicate with the **network controller** to request services. They enable network abstraction, so applications do not need to know the details of the infrastructure."
  },
  {
    "id": "json_component_count_objects_q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.7",
      "description_es": "Reconocer componentes de datos codificados en JSON",
      "description_en": "Recognize components of JSON-encoded data",
      "subtopic_id": "6.7",
      "subtopic_description": "JSON Components"
    },
    "question_es": "**Consulte la información.** ¿Cuántos **objetos** están presentes en los datos codificados en `JSON` proporcionados?",
    "question_en": "**Refer to the exhibit.** How many **objects** are present in the given `JSON`-encoded data?",
    "image": null,
    "code": "{\n  \"aaaUser\": {\n    \"attributes\": {\n      \"pwd\": \"passwordl\",\n      \"firstName\": \"Abraham\",\n      \"lastName\": \"Lincoln\",\n      \"phone\": \"5555551212\",\n      \"email\": \"test@cisco.com\"\n    },\n    \"children\": [\n      {\n        \"aaaUserDomain\": {\n          \"attributes\": {\n            \"name\": \"ExampleCisco\"\n          }\n        }\n      },\n      {\n        \"aaaUserRole\": {\n          \"attributes\": {\n            \"name\": \"admin\"\n          }\n        }\n      }\n    ]\n  }\n}",
    "options": [
      { "text_es": "uno", "text_en": "one", "isCorrect": false },
      { "text_es": "siete", "text_en": "seven", "isCorrect": false },
      { "text_es": "cuatro", "text_en": "four", "isCorrect": false },
      { "text_es": "nueve", "text_en": "nine", "isCorrect": true }
    ],
    "explanation_es": "Un **objeto `JSON`** es una colección de pares clave-valor encerrada entre llaves `{}`. Contando cada par de llaves, encontramos un total de **nueve** objetos anidados:\n1. El objeto raíz `{...}`\n2. `aaaUser: {...}`\n3. `attributes: {...}` (dentro de `aaaUser`)\n4. El primer `{...}` del array `children`\n5. `aaaUserDomain: {...}`\n6. `attributes: {...}` (dentro de `aaaUserDomain`)\n7. El segundo `{...}` del array `children`\n8. `aaaUserRole: {...}`\n9. `attributes: {...}` (dentro de `aaaUserRole`)",
    "explanation_en": "A **`JSON` object** is a collection of key-value pairs enclosed in curly braces `{}`. Counting every pair of braces, we find a total of **nine** nested objects:\n1. The root object `{...}`\n2. `aaaUser: {...}`\n3. `attributes: {...}` (inside `aaaUser`)\n4. The first `{...}` in the `children` array\n5. `aaaUserDomain: {...}`\n6. `attributes: {...}` (inside `aaaUserDomain`)\n7. The second `{...}` in the `children` array\n8. `aaaUserRole: {...}`\n9. `attributes: {...}` (inside `aaaUserRole`)"
  },
  {
    "id": "ccna-auto-prog-http-put-q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.5",
      "description_es": "Describir las características de las APIs basadas en REST (tipos de autenticación, CRUD, verbos HTTP y codificación de datos)",
      "description_en": "Describe characteristics of REST-based APIs (authentication types, CRUD, HTTP verbs, and data encoding)",
      "subtopic_id": "6.5",
      "subtopic_description": "HTTP verbs"
    },
    "question_es": "¿Cuándo se utiliza el método `PUT` dentro de `HTTP`?",
    "question_en": "When is the `PUT` method used within `HTTP`?",
    "image": null,
    "code": null,
    "options": [
      {
        "text_es": "cuando se necesita una operación no idempotente",
        "text_en": "when a nonidempotent operation is needed",
        "isCorrect": false
      },
      {
        "text_es": "para actualizar un servidor DNS",
        "text_en": "to update a DNS server",
        "isCorrect": true
      },
      {
        "text_es": "cuando se requiere una operación de solo lectura",
        "text_en": "when a read-only operation is required",
        "isCorrect": false
      },
      {
        "text_es": "para mostrar un sitio web",
        "text_en": "to display a web site",
        "isCorrect": false
      }
    ],
    "explanation_es": "El método `HTTP PUT` se utiliza para **crear o reemplazar** un recurso en un URI de destino específico. Una característica clave de `PUT` es que es **idempotente**, lo que significa que realizar la misma solicitud `PUT` varias veces produce el mismo resultado que realizarla una sola vez.\n\n### Análisis de las Opciones\n* **A. cuando se necesita una operación no idempotente:** Incorrecto. Esto describe al método `POST`. `PUT` es, por definición, idempotente.\n* **B. para actualizar un servidor DNS:** Correcto. Aunque es un ejemplo muy específico, es el único que describe una operación de **actualización/reemplazo**. En una `API RESTful` para la gestión de `DNS`, se podría usar una solicitud `PUT` a un endpoint como `/api/zones/example.com/records/myrecord` para actualizar ese registro `DNS` específico.\n* **C. cuando se requiere una operación de solo lectura:** Incorrecto. Las operaciones de solo lectura, como solicitar datos, se realizan con el método `GET`.\n* **D. para mostrar un sitio web:** Incorrecto. Esto es una forma de solicitar un recurso para su lectura, lo cual se hace con el método `GET`.",
    "explanation_en": "The `HTTP PUT` method is used to **create or replace** a resource at a specific target URI. A key characteristic of `PUT` is that it is **idempotent**, meaning that making the same `PUT` request multiple times produces the same result as making it once.\n\n### Options Analysis\n* **A. when a nonidempotent operation is needed:** Incorrect. This describes the `POST` method. `PUT` is, by definition, idempotent.\n* **B. to update a DNS server:** Correct. Although this is a very specific example, it is the only one that describes an **update/replacement** operation. In a `RESTful API` for `DNS` management, you could use a `PUT` request to an endpoint like `/api/zones/example.com/records/myrecord` to update that specific `DNS` record.\n* **C. when a read-only operation is required:** Incorrect. Read-only operations, such as requesting data, are performed with the `GET` method.\n* **D. to display a web site:** Incorrect. This is a form of requesting a resource for reading, which is done with the `GET` method."
  },
  {
    "id": "ccna-auto-prog-json-key-type-q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.7",
      "description_es": "Reconocer componentes de datos codificados en JSON",
      "description_en": "Recognize components of JSON-encoded data",
      "subtopic_id": "6.7",
      "subtopic_description": "JSON components"
    },
    "question_es": "Consulte la imagen. ¿Qué representa `apple` dentro de los datos `JSON`?",
    "question_en": "Refer to the exhibit. What does `apple` represent within the `JSON` data?",
    "image": null,
    "code": "{\"apple\": [\"red\", 1], \"ripe\": true}",
    "options": [
      {
        "text_es": "Array",
        "text_en": "Array",
        "isCorrect": false
      },
      {
        "text_es": "Objeto",
        "text_en": "Object",
        "isCorrect": false
      },
      {
        "text_es": "String",
        "text_en": "String",
        "isCorrect": true
      },
      {
        "text_es": "Número",
        "text_en": "Number",
        "isCorrect": false
      }
    ],
    "explanation_es": "En `JSON`, los datos se estructuran en pares de clave-valor (`key-value`). Según la especificación `JSON`, la **clave** siempre debe ser un tipo de dato **`String`** (cadena de texto), encerrada entre comillas dobles.\n\n### Desglose del Código `JSON`\nEn el fragmento `\"apple\": [\"red\", 1]`, podemos identificar dos componentes principales:\n| Componente | Valor | Tipo de Dato `JSON` |\n|---|---|---|\n| **Clave (Key)** | `\"apple\"` | **`String`** |\n| **Valor (Value)** | `[\"red\", 1]` | `Array` |\n\nLa pregunta se refiere a lo que es `\"apple\"` en sí mismo, que actúa como la clave en el par. Por lo tanto, es un `String`.\n\n* **Array:** Sería la respuesta si la pregunta fuera sobre lo que representa `[\"red\", 1]`.\n* **Object:** Es el tipo de dato que contiene todo el conjunto, delimitado por `{}`.",
    "explanation_en": "In `JSON`, data is structured in `key-value` pairs. According to the `JSON` specification, the **key** must always be a **`String`** data type, enclosed in double quotes.\n\n### Breakdown of the `JSON` Code\nIn the snippet `\"apple\": [\"red\", 1]`, we can identify two main components:\n| Component | Value | `JSON` Data Type |\n|---|---|---|\n| **Key** | `\"apple\"` | **`String`** |\n| **Value** | `[\"red\", 1]` | `Array` |\n\nThe question asks what `\"apple\"` itself represents, which acts as the key in the pair. Therefore, it is a `String`.\n\n* **Array:** This would be the answer if the question asked what `[\"red\", 1]` represents.\n* **Object:** This is the data type that contains the entire structure, enclosed by `{}`."
  },
  {
    "id": "ccna-auto-prog-dna-center-advantage-q1",
    "category": "6.0-automation-programmability",
    "isMultipleChoice": false,
    "topic": {
      "id": "6.2",
      "description_es": "Comparar redes tradicionales con redes basadas en controladores",
      "description_en": "Compare traditional networks with controller-based networking",
      "subtopic_id": "6.2",
      "subtopic_description": "Controller-based networking"
    },
    "question_es": "¿Cuál es una ventaja de `Cisco DNA Center` en comparación con la gestión tradicional de dispositivos de campus?",
    "question_en": "What is an advantage of `Cisco DNA Center` versus traditional campus device management?",
    "image": null,
    "code": null,
    "options": [
      {
        "text_es": "Está diseñado principalmente para proporcionar aseguramiento de la red.",
        "text_en": "It is designed primarily to provide network assurance.",
        "isCorrect": false
      },
      {
        "text_es": "Soporta alta disponibilidad para funciones de gestión cuando opera en modo clúster.",
        "text_en": "It supports high availability for management functions when operating in cluster mode.",
        "isCorrect": false
      },
      {
        "text_es": "Soporta numerosas opciones de extensibilidad, incluyendo adaptadores inter-dominios y `SDKs` de terceros.",
        "text_en": "It supports numerous extensibility options, including cross-domain adapters and third-party `SDKs`.",
        "isCorrect": true
      },
      {
        "text_es": "Permite el autodescubrimiento fácil de elementos de red en un despliegue `brownfield`.",
        "text_en": "It enables easy autodiscovery of network elements in a brownfield deployment.",
        "isCorrect": false
      }
    ],
    "explanation_es": "`Cisco DNA Center` es una plataforma de gestión de red centralizada que representa un cambio fundamental respecto a la gestión tradicional, dispositivo por dispositivo. Una de sus ventajas más significativas es su naturaleza abierta y programable.\n\n### Análisis de las Opciones\n* **A:** Incorrecto. El aseguramiento de la red (Assurance) es solo **una** de las funciones principales de `DNA Center`, junto con la automatización y la política. No es su único propósito principal.\n* **B:** Incorrecto. Si bien `DNA Center` soporta alta disponibilidad, muchas soluciones de gestión de red tradicionales también lo hacen. No es una ventaja diferenciadora clave.\n* **C:** Correcto. Esta es una ventaja fundamental. `Cisco DNA Center` está diseñado como una plataforma extensible que puede integrarse con otros sistemas (como `ServiceNow` para `ITSM`, o `Splunk` para `SIEM`) a través de sus `APIs` y `SDKs`. La gestión tradicional carece de esta profunda capacidad de integración programática.\n* **D:** Incorrecto. El autodescubrimiento es una característica de `DNA Center`, pero también es una función común en muchas herramientas de gestión de redes tradicionales (`NMS`).",
    "explanation_en": "`Cisco DNA Center` is a centralized network management platform that represents a fundamental shift from traditional, device-by-device management. One of its most significant advantages is its open and programmable nature.\n\n### Options Analysis\n* **A:** Incorrect. Network Assurance is only **one** of the main functions of `DNA Center`, along with automation and policy. It is not its sole primary purpose.\n* **B:** Incorrect. While `DNA Center` supports high availability, many traditional network management solutions also do. It is not a key differentiating advantage.\n* **C:** Correct. This is a core advantage. `Cisco DNA Center` is designed as an extensible platform that can integrate with other systems (like `ServiceNow` for `ITSM`, or `Splunk` for `SIEM`) through its `APIs` and `SDKs`. Traditional management lacks this deep programmatic integration capability.\n* **D:** Incorrect. Autodiscovery is a feature of `DNA Center`, but it is also a common function in many traditional Network Management System (`NMS`) tools."
  }
]
