{
    "subnet_gen_page_title": "Subnetting Generator - CCNA Blueprint",
    "subnet_gen_main_title": "IPv4 Subnetting Tool",
    "subnet_gen_tab_calculator": "Calculator",
    "subnet_gen_tab_exercises": "Exercises",
    "subnet_gen_calculator_title": "Mode: Subnet Calculator",
    "subnet_gen_calc_type_legend": "Calculation Type",
    "subnet_gen_calc_type_classful": "Classful",
    "subnet_gen_calc_type_vlsm": "Classless (VLSM)",
    "subnet_gen_classful_tooltip_html": "<b>Classful Subnetting (Legacy Rule):</b><br>This mode assumes the historical rule where the first subnet (Subnet Zero) and the last (All-Ones Subnet) were reserved and not considered usable.<br><br><b>Practical Example:</b> If you need <b>2 usable subnets</b>, you must calculate by asking for a total of <b>4 subnets</b> (the 2 you need + 2 reserved).",
    "subnet_gen_classful_subtitle": "Classful Subnetting",
    "subnet_gen_network_ip_label": "Network IP Address:",
    "subnet_gen_ip_placeholder_classful": "Ex: 192.168.1.0",
    "subnet_gen_error_invalid_ip": "Invalid IP format.",
    "subnet_gen_requirement_legend": "Requirement (choose one):",
    "subnet_gen_req_subnets": "Number of Usable Subnets:",
    "subnet_gen_req_hosts": "Minimum Usable Hosts per Subnet:",
    "subnet_gen_req_placeholder_min2": "Min 2",
    "subnet_gen_button_calculate": "Calculate",
    "subnet_gen_button_clear": "Clear",
    "subnet_gen_vlsm_subtitle": "Classless Subnetting (VLSM)",
    "subnet_gen_network_prefix_label": "Network IP/Prefix:",
    "subnet_gen_ip_placeholder_vlsm": "Ex: 172.16.0.0/22",
    "subnet_gen_error_invalid_cidr": "Invalid CIDR format (e.g., 10.0.0.0/8).",
    "subnet_gen_vlsm_req_label": "Host Requirements per Subnet:",
    "subnet_gen_vlsm_hosts_placeholder": "Hosts",
    "subnet_gen_vlsm_name_placeholder": "Name (Optional)",
    "subnet_gen_vlsm_add_req_button": "Add Requirement",
    "subnet_gen_button_calculate_vlsm": "Calculate VLSM",
    "subnet_gen_results_title": "Calculation Results:",
    "subnet_gen_results_placeholder": "Enter data and click calculate.",
    "subnet_gen_exercises_title": "Mode: Exercise Generator",
    "subnet_gen_exercise_type_label": "Subnetting Type:",
    "subnet_gen_exercise_generate_button": "Generate New Exercise",
    "subnet_gen_exercise_problem_title": "Problem:",
    "subnet_gen_exercise_problem_placeholder": "Click \"Generate New Exercise\".",
    "subnet_gen_exercise_your_solution_title": "Your Solution:",
    "subnet_gen_exercise_solution_instructions": "Fill in the details for each subnet:",
    "subnet_gen_exercise_check_button": "Check Answer",
    "subnet_gen_exercise_show_solution_button": "Show Solution",
    "subnet_gen_exercise_detailed_solution_title": "Detailed Solution:",
    "subnet_gen_exercise_explanation_method": "Method:",
    "subnet_gen_exercise_method_magic": "Magic Number",
    "subnet_gen_exercise_method_wildcard": "Wildcard (Conceptual)",
    "subnet_gen_exercise_show_steps_button": "Show Steps",
    "subnet_gen_error_min_req": "There must be at least one requirement.",
    "subnet_gen_results_no_subnets": "No subnets were generated.",
    "subnet_gen_results_generated": "${count} subnet(s) generated.",
    "subnet_gen_results_common_mask": "Common Mask:",
    "subnet_gen_results_usable_hosts": "Usable Hosts p/Subnet:",
    "subnet_gen_results_total_hosts": "Total:",
    "subnet_gen_results_zero_all_ones_note": "Highlighted rows: Subnet Zero/All-Ones (historical).",
    "subnet_gen_results_usable_ips": "Usable IPs p/Subnet:",
    "subnet_gen_results_total_ips": "Total IPs:",
    "subnet_gen_header_name": "Name",
    "subnet_gen_header_subnet": "Subnet IP",
    "subnet_gen_header_prefix_mask": "Prefix (Mask)",
    "subnet_gen_header_range": "Usable Range",
    "subnet_gen_header_broadcast": "Broadcast",
    "subnet_gen_header_total_ips": "Total IPs",
    "subnet_gen_header_usable_ips": "Usable IPs",
    "subnet_gen_header_requested": "IPs Req.",
    "subnet_gen_header_efficiency": "Efficiency",
    "subnet_gen_label_zero": "(Subnet Zero)",
    "subnet_gen_label_all_ones": "(All-Ones)",
    "subnet_gen_summary_original": "Original Network:",
    "subnet_gen_summary_mask": "Applied Mask:",
    "subnet_gen_summary_subnets": "Subnets Created:",
    "subnet_gen_summary_hosts": "Hosts per Subnet:",
    "subnet_gen_summary_allocated": "Total Allocated:",
    "subnet_gen_summary_utilization": "utilization",
    "subnet_gen_summary_remaining": "Remaining Space:",
    "subnet_gen_summary_remaining_ips": "IPs",
    "subnet_gen_summary_range": "Range:",
    "subnet_gen_button_copy": "Copy Table",
    "subnet_gen_copy_feedback": "Copied!",
    "subnet_gen_text_na": "N/A",
    "subnet_gen_error_generate_exercise": "Error generating exercise.",
    "subnet_gen_error_no_solution": "Error: Invalid solution.",
    "subnet_gen_header_mask_prefix": "Mask / Prefix",
    "subnet_gen_header_first": "First Host",
    "subnet_gen_header_last": "Last Host",
    "subnet_gen_placeholder_net": "Ex: 192.168.1.0",
    "subnet_gen_placeholder_mask": "Ex: /24 or 255...",
    "subnet_gen_placeholder_first": "Ex: 192.168.1.1",
    "subnet_gen_placeholder_last": "Ex: 192.168.1.254",
    "subnet_gen_placeholder_broad": "Ex: 192.168.1.255",
    "subnet_gen_text_subnet": "Subnet",
    "subnet_gen_error_mismatch_answers": "Error: The number of answers does not match the solution.",
    "subnet_gen_feedback_success": "All answers are correct! Excellent work!",
    "subnet_gen_feedback_errors": "Errors found in ${count} subnet(s). Review marked fields or show the solution.",
    "subnet_gen_text_expected": "Expected:",
    "subnet_gen_error_no_solution_available": "No solution available.",
    "subnet_gen_explanation_title_magic": "Explanation (Magic Number)",
    "subnet_gen_explanation_title_wildcard": "Explanation (Wildcard Conceptual)",
    "subnet_gen_error_no_explanation_data": "Not enough data to generate explanation.",
    "subnet_gen_error_no_exercise": "Generate an exercise first.",
    "subnet_gen_error_explanation_generic": "An error occurred while generating the explanation.",
    "...": "...",
    "ex_mode_title": "Mode: Exercise Generator",
    "ex_config_title": "Configure Exercise",
    "ex_problem_type": "Problem Type:",
    "ex_type_classful_legacy": "Classful Subnetting (Legacy)",
    "ex_type_identify_network": "Network Analysis (ID, Range, etc.)",
    "ex_type_calculate_mask": "Calculate Mask (Reverse Eng.)",
    "ex_type_summarization": "Route Summarization (Supernetting)",
    "ex_type_vlsm_scenario": "VLSM Design (Scenario)",
    "ex_type_next_network": "Identify Next Network (Hop)",
    "ex_difficulty": "Difficulty:",
    "ex_difficulty_easy": "Easy",
    "ex_difficulty_medium": "Medium",
    "ex_difficulty_hard": "Hard",
    "ex_generate_new": "Generate New Exercise",
    "ex_problem_title": "Problem:",
    "ex_answer_title": "Your Solution:",
    "ex_check_btn": "Check Answer",
    "ex_show_solution": "Show Solution",
    "ex_find_network_problem": "Analyze the following host IP: {ipStr} (Mask: {maskStr}).<br>Calculate the following:",
    "ex_label_network_address": "Network Address",
    "ex_label_subnet_mask": "Subnet Mask",
    "ex_label_broadcast_address": "Broadcast Address",
    "ex_label_first_usable_host": "First Usable Host",
    "ex_label_last_usable_host": "Last Usable Host",
    "ex_label_wildcard_mask": "Wildcard Mask",
    "ex_label_mask_ddn": "Mask (DDN)",
    "ex_label_mask_cidr": "Mask (CIDR)",
    "ex_classful_req_subnets": "at least {value} usable subnets (-2)",
    "ex_classful_req_hosts": "at least {value} hosts per subnet",
    "ex_classful_problem": "You must subnet the classful network {baseNetwork} to meet the requirement of {reqText}.<br>Calculate the following:",
    "ex_label_new_mask_cidr": "New Mask (CIDR Format)",
    "ex_label_usable_subnets": "Usable Subnets (-2)",
    "ex_label_nth_subnet_network": "Network Address of the {index}th Usable Subnet",
    "ex_label_nth_subnet_host_range": "Host Range of the {index}th Usable Subnet",
    "ex_calculate_mask_problem_hosts": "You are working with the base network {baseCidr}. You need to create subnets that each support at least {hosts} usable hosts.<br>Calculate the following:",
    "ex_calculate_mask_problem_subnets": "You are working with the base network {baseCidr}. You need to divide it into at least {subnets} subnets.<br>Calculate the following:",
    "ex_label_new_mask_ddn": "New Mask (DDN)",
    "ex_label_resulting_hosts": "Resulting Usable Hosts",
    "ex_label_resulting_subnets": "Resulting Subnets",
    "ex_summarization_problem": "A router is advertising the following networks:<br>{ipList}What is the most efficient summary route (supernet) that encompasses these networks?",
    "ex_label_summary_route": "Summary Route (Network)",
    "ex_label_summary_mask": "Summary Mask (CIDR)",
    "ex_next_network_problem": "Given the subnet {networkCidr}, what is the network address of the next subnet of the same size?",
    "ex_label_next_network": "Next Network Address",
    "ex_vlsm_req_corp": "Corp",
    "ex_vlsm_req_sales": "Sales",
    "ex_vlsm_req_it": "IT",
    "ex_vlsm_req_mkt": "Mkt",
    "ex_vlsm_req_wan1": "WAN1",
    "ex_vlsm_req_wan2": "WAN2",
    "ex_vlsm_req_neta": "Net-A",
    "ex_vlsm_req_netb": "Net-B",
    "ex_vlsm_req_netc": "Net-C",
    "ex_vlsm_req_admin": "Admin",
    "ex_vlsm_req_support": "Support",
    "ex_vlsm_hosts_label": "{hosts} hosts",
    "ex_vlsm_problem": "Given the base network {baseCidr}, calculate the VLSM assignments for the following requirements (remember to sort them): {reqListHtml}<br>Complete the information for the {boldLargestNetworks}:",
    "ex_vlsm_largest_networks_text": "two LARGEST networks",
    "ex_vlsm_req_network_address": "Network ({reqName}) - Network Addr.",
    "ex_vlsm_req_mask_cidr": "Network ({reqName}) - Mask (CIDR)",
    "ex_feedback_incorrect": "Incorrect answer.",
    "ex_feedback_correct": "Correct!",
    "ex_feedback_great": "Excellent!",
    "ex_feedback_all_correct": "All your answers are correct.",
    "ex_feedback_almost": "Almost...",
    "ex_feedback_some_incorrect": "Some answers are incorrect (marked in red). Keep trying!",
    "ex_error_generating": "Error generating the exercise.",
    "ex_solution_showing": "Showing the correct solution.",
    "ex_ph_ip_network": "Ex: 192.168.1.0",
    "ex_ph_ip_mask": "Ex: 255.255.255.192",
    "ex_ph_ip_broadcast": "Ex: 192.168.1.63",
    "ex_ph_ip_first": "Ex: 192.168.1.1",
    "ex_ph_ip_last": "Ex: 192.168.1.62",
    "ex_ph_cidr": "Ex: /26",
    "ex_ph_number": "Ex: 8",
    "ex_ph_ip_range": "Ex: 192.168.1.129 - 192.168.1.190",
    "ex_ph_wildcard": "Ex: 0.0.0.63",
    "ex_practice_mode": "Practice Mode",
    "ex_challenge_mode": "Challenge Mode ‚öîÔ∏è",
    "ex_start_challenge_btn": "Start Challenge!",
    "ex_challenge_counter": "Question {current} of {total}",
    "ex_next_question_btn": "Next Question",
    "ex_challenge_results_title": "Challenge Complete!",
    "ex_final_score": "Your final score is:",
    "ex_view_results_btn": "Back to Start",
    "ex_coming_soon_title": "Coming Soon!",
    "ex_coming_soon_desc": "This exercise mode is under construction. Check back soon!",
    "fb_detailed_solution": "Detailed Solution",
    "fb_not_available": "The explanation for this exercise is not yet available.",
    "fb_mode1_req_subnets": "The requirement is {value} usable subnets (using the historical -2 rule).",
    "fb_mode1_req_hosts": "The requirement is {value} usable hosts per subnet.",
    "fb_mode1_step2_desc": "We look for the formula {formula}. With N={finalBits}, we get {calc}, which meets the requirement. We need to borrow {finalBits} bits from the host portion.",
    "fb_mode1_step3_desc": "The Class C mask is /24. We add the borrowed bits: 24 + {bitsNeeded} = {newCidr}. This equals {maskDDN}.",
    "fb_mode1_step4_desc": "Total Subnets: 2^{bitsNeeded} = {totalSubnets}.<br>Usable Subnets: {totalSubnets} - 2 = {usableSubnets}.<br>Host Bits remaining: 32 - {newCidr} = {hostBits}.<br>Usable Hosts/Subnet: 2^{hostBits} - 2 = {usableHosts}.",
    "fb_mode2_analyze": "Let's analyze the IP {ipStr} with mask {maskStr}.",
    "fb_mode2_step1_title": "1. Identify Mask",
    "fb_mode2_step1_desc": "The mask {maskStr} is {maskDDN}. The 'interesting octet' is the {octet}rd, as it is neither 255 nor 0.",
    "fb_mode2_step2_title": "2. Find the 'Magic Number' (Increment)",
    "fb_mode2_step2_desc": "We calculate 256 - {octetValue} (octet value) = {magicNumber}. The networks increment by {magicNumber} in the {octet}rd octet.",
    "fb_mode2_step3_title": "3. Find the Network ID",
    "fb_mode2_step3_desc": "The value {ipOctetValue} (from our IP) in the {octet}rd octet is in the range of the {networkOctet} increment. Therefore, the Network ID is {networkIP}.",
    "fb_mode2_step4_title": "4. Find the Broadcast Address",
    "fb_mode2_step4_desc": "The next network would start at {nextNetworkOctet} (in the 3rd octet). Our broadcast address is the IP just before it: {broadcastIP}.",
    "fb_mode2_step5_title": "5. Define the Usable Range",
    "fb_mode2_step5_desc": "The range is (Network ID + 1) to (Broadcast - 1).<br>First IP: {firstHost}<br>Last IP: {lastHost}",
    "fb_mode3_intro_hosts": "Problem: Base network {baseCidr}, need {hosts} usable hosts.",
    "fb_mode3_intro_subnets": "Problem: Base network {baseCidr}, need {subnets} subnets.",
    "fb_mode3_step1_desc_hosts": "We look for the formula {formula}. With H={finalBits}, we get {calc}, which meets the requirement. We must reserve {hostBits} bits for hosts.",
    "fb_mode3_step1_desc_subnets": "We look for the formula {formula}. With N={finalBits}, we get {calc}, which meets the requirement. We must borrow {subnetBits} bits for subnets.",
    "fb_mode3_step2_desc_hosts": "Total bits is 32. We subtract the host bits: 32 - {hostBits} = {newPrefix}.",
    "fb_mode3_step2_desc_subnets": "Base prefix is {basePrefix}. We add the subnet bits: {basePrefix} + {subnetBits} = {newPrefix}.",
    "fb_mode3_step3_desc": "A {maskCIDR} prefix translates to the decimal mask {maskDDN}.",
    "fb_mode3_step4_desc_hosts": "Subnet Bits: {newPrefix} (new) - {basePrefix} (base) = {subnetBits}.<br>Resulting Subnets: 2^{subnetBits} = {totalSubnets}.",
    "fb_mode3_step4_desc_subnets": "Host Bits: 32 (total) - {newPrefix} (new) = {hostBits}.<br>Usable Hosts: 2^{hostBits} - 2 = {totalHosts}.",
    "fb_mode4_step2_desc": "Comparing the list, we see the first {commonBits} bits are identical (000100xx).",
    "fb_mode4_step3_desc": "The original mask was /{basePrefix}. We add the common bits from the octet: {basePrefix} + {commonBits} = {newPrefix}.",
    "fb_mode5_desc": "For VLSM, the best explanation is the solution table. Please review the table generated by 'Show Solution' to see the step-by-step allocation.",
    "fb_mode6_step1_desc": "A /{prefix} prefix tells us the 'interesting octet' (where increments happen) is the {octet}th.",
    "fb_mode6_step2_desc": "The block size in the {octet}th octet is 2^(8 - {bitsInOctet}) = {magicNumber}. (Simplified calc for /25-/30).",
    "fb_mode6_step3_desc": "The current network is at {networkOctet}. The next increment is {networkOctet} + {magicNumber} = {nextNetworkOctet}.",
    "fb_mode6_step4_desc": "The next network's address is {nextNetwork}.",
    "fb_mode2_step1_title_cidr": "1. Calculate CIDR Mask",
    "fb_mode2_step1_desc_cidr": "We convert the DDN mask <code>{maskDDN}</code> to binary: <br><code class='text-primary'>{maskBin}</code><br>We count the '1' bits from left to right. The total is {prefix}. <br>Answer: <code>/{prefix}</code>",
    "fb_mode2_step2_desc_wildcard": "Method A (Decimal): Subtract the DDN mask from 255.255.255.255.",
    "fb_mode2_step2_desc_wildcard_bin": "Method B (Binary): We simply invert the bits of the binary mask ('1's become '0's and vice-versa).",
    "fb_mode2_step4_title_broadcast": "4. Calculate Broadcast Address",
    "fb_mode2_step4_desc_broadcast": "Method A (Wildcard): Add the Wildcard to the Network ID.",
    "fb_mode2_step4_desc_broadcast_magic": "Method B (Magic Number):",
    "fb_mode2_step4_magic_1": "The 'interesting octet' is the {interestingOctet}th (value {interestingOctetValue}).",
    "fb_mode2_step4_magic_2": "The 'Magic Number' is 256 - {interestingOctetValue} = {magicNumber}.",
    "fb_mode2_step4_magic_3": "The network increments are 0, {magicNumber}, {magicNumber2x}, etc. Our network ({networkInterestingOctetValue}) is the first.",
    "fb_mode2_step4_magic_4": "The Broadcast is (Next Increment - 1). The next increment is {magicNumber}.",
    "fb_mode2_step4_magic_5": "The broadcast is {broadcastDDN}.",
    "fb_mode2_step5_title_range": "5. Calculate Usable Range",
    "fb_mode2_step5_desc_range": "The range is (Network ID + 1) to (Broadcast - 1).",
    "fb_mode2_step5_desc_range_first": "First IP: <code>{networkDDN} + 1</code> = <code>{firstHostDDN}</code>",
    "fb_mode2_step5_desc_range_last": "Last IP: <code>{broadcastDDN} - 1</code> = <code>{lastHostDDN}</code>",
    "fb_label_ddn": "DDN:",
    "fb_label_binario": "BINARY:",
    "fb_label_cidr": "CIDR:",
    "fb_mode2_step2_title_wildcard": "2. Calculate Wildcard Mask",
    "fb_mode2_step2_method_a": "Method A (Decimal): Subtract the DDN mask from 255.255.255.255.",
    "fb_mode2_step2_method_b": "Method B (Binary): Invert the binary mask bits ('1's become '0's and vice-versa) and convert to DDN.",
    "fb_label_inverted": "Inverted:",
    "fb_label_wildcard": "Wildcard:",
    "fb_label_all_255": "All 255s:",
    "fb_label_mask_minus": "- Mask:",
    "fb_mode2_step1_title_from_ddn": "1. Calculate CIDR Mask (from DDN)",
    "fb_mode2_step1_desc_from_ddn_1": "We convert the DDN mask",
    "fb_mode2_step1_desc_from_ddn_1b": "to binary:",
    "fb_mode2_step1_desc_from_ddn_2": "We count the '1' bits from left to right.",
    "fb_mode2_step1_desc_from_ddn_3": "The total is",
    "fb_mode2_step1_desc_from_ddn_3b": "Answer:",
    "fb_mode2_step1_title_from_cidr": "1. Calculate DDN Mask (from CIDR)",
    "fb_mode2_step1_desc_from_cidr_1": "We convert the CIDR mask",
    "fb_mode2_step1_desc_from_cidr_1b": "to binary (total",
    "fb_mode2_step1_desc_from_cidr_1c": "bits '1'):",
    "fb_mode2_step1_desc_from_cidr_2": "We convert the binary to decimal, octet by octet:",
    "fb_mode2_step3_title_netid": "3. Calculate Network ID",
    "fb_mode2_step3_desc_netid": "We perform a bitwise AND operation between the Host IP and the DDN Mask.",
    "fb_label_ip": "IP:",
    "fb_label_and_op": "& (AND):",
    "fb_label_mask": "Mask:",
    "fb_label_red": "Network",
    "fb_label_wildcard_add": "+ Wildcard:",
    "fb_label_broadcast": "Broadcast:",
    "fb_mode2_step4_magic_1_a": "The 'interesting octet' is the",
    "fb_mode2_step4_magic_1_b": "value",
    "fb_mode2_step4_magic_2_a": "The 'Magic Number' is 256 -",
    "fb_mode2_step4_magic_3_a": "The network increments are 0,",
    "fb_mode2_step4_magic_3_b": "etc. Our network",
    "fb_mode2_step4_magic_3_c": "is the first one.",
    "fb_mode2_step4_magic_4_a": "The Broadcast is (Next Increment - 1). The next increment is",
    "fb_mode2_step4_magic_5_a": "The broadcast is",
    "fb_mode2_step5_desc_range_first_a": "First IP:",
    "fb_mode2_step5_desc_range_last_a": "Last IP:",
    "ex_label_total_subnets": "Total Subnets Created",
    "ex_label_usable_hosts_per_subnet": "Usable Hosts per Subnet",
    "fb_mode3_step4_desc_subnets_1": "Subnet Bits = ",
    "fb_mode3_step4_desc_subnets_2": " (",
    "fb_mode3_step4_desc_subnets_3": " - ",
    "fb_mode3_step4_desc_subnets_4": ")",
    "fb_mode3_step4_desc_hosts_1": "Host Bits = ",
    "fb_mode3_step4_desc_hosts_2": " (32 - ",
    "fb_mode3_step4_desc_hosts_3": ")",
    "ex_mode3_problem_hosts": "You are working with the network <strong>{baseNetwork}</strong>. You need to create subnets that each support at least <strong>{hosts} usable hosts</strong>.<br>Calculate the following:",
    "ex_mode3_problem_subnets": "You are working with the network <strong>{baseNetwork}</strong>. You need to divide it into at least <strong>{subnets} subnets</strong>.<br>Calculate the following:",
    "ex_label_network_class": "Network Class",
    "ex_label_default_mask": "Default Mask (CIDR)",
    "ex_ph_class": "Ex: C",
    "fb_mode3_formula_hosts": "2<sup>H</sup> - 2 >= N<sub>hosts</sub>",
    "fb_mode3_formula_subnets": "2<sup>nBits</sup> >= N<sub>subnets</sub>",
    "fb_mode3_step1_title": "1. Identify Class and Default Mask",
    "fb_mode3_step1_desc_1": "The base network ",
    "fb_mode3_step1_desc_2": " starts with ",
    "fb_mode3_step1_desc_3": ", which classifies it as ",
    "fb_mode3_step1_desc_4": "The default mask for Class ",
    "fb_mode3_step1_desc_5": " is ",
    "fb_mode3_step1_desc_6": " (",
    "fb_mode3_step1_desc_7": "), which gives us ",
    "fb_mode3_step1_desc_8": " host bits to work with.",
    "fb_mode3_step2_title": "2. Calculate Bits Needed",
    "fb_mode3_step2_desc_hosts_1": "The requirement is ",
    "fb_mode3_step2_desc_hosts_2": " usable hosts. We use the formula ",
    "fb_mode3_formula_base": "2",
    "fb_mode3_formula_exponent_host": "H",
    "fb_mode3_formula_operator": ">=",
    "fb_mode3_formula_variable": "N",
    "fb_mode3_formula_subscript_host": "hosts",
    "fb_mode3_step2_desc_hosts_3": " (where H = host bits).",
    "fb_mode3_step2_desc_hosts_4": ". We need to reserve ",
    "fb_mode3_step2_desc_hosts_5": " bits for the host portion.",
    "fb_mode3_step2_desc_subnets_1": "The requirement is ",
    "fb_mode3_step2_desc_subnets_2": ". We use the formula ",
    "fb_mode3_formula_exponent_subnet": "nBits",
    "fb_mode3_formula_subscript_subnet": "subnets",
    "fb_mode3_step2_desc_subnets_3": " (where N = subnet bits).",
    "fb_mode3_step2_desc_subnets_4": ". We need to borrow ",
    "fb_mode3_step2_desc_subnets_5": " bits from the host portion.",
    "fb_mode3_step3_title": "3. Calculate New Mask",
    "fb_mode3_step3_desc_hosts_1": "Total bits (32) - host bits (",
    "fb_mode3_step3_desc_hosts_2": ") = ",
    "fb_mode3_step3_desc_hosts_3": ".",
    "fb_mode3_step3_desc_subnets_1": "Default prefix (",
    "fb_mode3_step3_desc_subnets_2": ") + subnet bits (",
    "fb_mode3_step3_desc_subnets_3": ") = ",
    "fb_mode3_step3_desc_subnets_4": ".",
    "fb_mode3_step3_desc_common_1": "A prefix of ",
    "fb_mode3_step3_desc_common_2": " converts to the DDN mask: ",
    "fb_mode3_step4_title": "4. Calculate Resulting Totals",
    "fb_mode3_step4_desc_subnets_calc_text": "Subnet Bits = (New Mask) - (Default Mask)",
    "fb_mode3_step4_desc_hosts_calc_text": "Host Bits = (Total Bits) - (New Mask)",
    "fb_mode3_step4_desc_minus_two": "* The \"- 2\" is subtracted because the first IP in a subnet (Network ID) and the last IP (Broadcast) cannot be assigned to hosts.",
    "fb_mode6_intro": "Let's analyze the subnet",
    "fb_mode6_step1_title": "1. Identify Interesting Octet",
    "fb_mode6_step1_desc_1": "A",
    "fb_mode6_step1_desc_2": "prefix tells us the 'interesting octet' (where increments happen) is the",
    "fb_mode6_step2_title": "2. Find the 'Magic Number' (Increment)",
    "fb_mode6_step2_desc_1": "We convert the",
    "fb_mode6_step2_desc_2": "prefix to its DDN mask:",
    "fb_mode6_step2_desc_3": "The value in the",
    "fb_mode6_step2_desc_4": "th octet is",
    "fb_mode6_step2_desc_5": "We calculate the Magic Number (increment): 256 -",
    "fb_mode6_step3_title": "3. Calculate Next Hop",
    "fb_mode6_step3_desc_1": "The current network is at",
    "fb_mode6_step3_desc_2": "The next increment is",
    "fb_mode6_step4_title": "4. Define Next Network",
    "fb_mode6_step4_desc_1": "The next network's address is",
    "fb_mode4_intro": "The octet that is changing ('interesting') is the <strong>{octet}th</strong>.",
    "fb_mode4_step1_desc": "We convert the value of the {octet}th octet of each network to binary:",
    "fb_mode4_step2_desc_2": "bits are identical.",
    "fb_mode4_step2_highlight": "(Highlighted in bold in the table above)",
    "fb_mode4_step3_desc_3": "The new summary mask (supernet) is",
    "fb_mode4_step4_desc": "The supernet network address is always the first (lowest) network in the list.",
    "fb_mode4_step5_desc": "The most efficient summary route is",
    "fb_mode4_step1_title": "1. List Networks & Find Interesting Octet",
    "fb_mode4_step1_desc_3": "The <strong>{octet}th octet</strong> (where the numbers change) is our 'interesting octet'.",
    "fb_mode4_step2_title": "2. Convert Interesting Octet to Binary",
    "fb_mode4_step2_desc_1": "We convert only the numbers from that octet to 8-bit binary:",
    "fb_mode4_step3_title": "3. Find Common Bits",
    "fb_mode4_step3_desc_1": "We compare the bits from left to right to find the identical pattern.",
    "fb_mode4_step3_desc_2": "The first <strong>{commonBits} bits</strong> (<code>{commonBitsPattern}</code>) are identical in all networks.",
    "fb_mode4_step4_title": "4. Calculate New Subnet Mask (Prefix)",
    "fb_mode4_step4_desc_1": "Bits from fixed octets (before the {octet}th):",
    "fb_mode4_step4_desc_2": "Common bits found (in the {octet}th octet):",
    "fb_mode4_step4_desc_3": "We add these bits to get the new supernet prefix:",
    "fb_mode4_step4_desc_4": "The new mask is <strong>{newMask}</strong> (or <strong>{newMaskDDN}</strong>).",
    "fb_mode4_step5_title": "5. Calculate New Network ID & Final Answer",
    "fb_mode4_step5_desc_1": "The supernet ID is always the lowest network in the list, using the new mask.",
    "fb_mode4_step5_desc_2": "Answer: <strong><code>{summaryRoute}{summaryMask}</code></strong>",
    "fb_mode4_verify_title": "üí° Verification (Why does this work?)",
    "fb_mode4_verify_desc_1": "Our new network <strong>{summaryRoute}{summaryMask}</strong> has a range of <strong>{summaryRange}</strong>.",
    "fb_mode4_verify_desc_2": "This single range perfectly covers all original networks:",
    "fb_mode4_design_note_title": "üí° Design Note: Efficiency Analysis",
    "fb_mode4_eff_cat_Eficiente": "Efficient",
    "fb_mode4_eff_cat_Aceptable": "Acceptable",
    "fb_mode4_eff_cat_Ineficiente": "Inefficient (Bad Design)",
    "fb_mode4_design_note_perfect_1": "This is a 'perfect' summary!",
    "fb_mode4_design_note_perfect_2": "The <strong>{numNetworks}</strong> original (<code>{basePrefix}</code>) networks occupy exactly <strong>100%</strong> of the space (<strong>{usedIPs}</strong> IPs) in the new supernet (<code>{summaryMask}</code>), which contains a total of <strong>{totalIPs}</strong> IPs.",
    "fb_mode4_design_note_perfect_3": "In the real world, this is the ideal scenario.",
    "fb_mode4_design_note_inefficient_1": "This supernet is <strong>{eff}%</strong> efficient.",
    "fb_mode4_design_note_inefficient_2": "The summary block (<code>{summaryMask}</code>) covers <strong>{totalIPs}</strong> IPs, but you are only using <strong>{usedIPs}</strong> IPs from <strong>{numNetworks}</strong> networks.",
    "fb_mode4_design_note_inefficient_3": "The following networks are 'holes' (advertised but not used):",
    "fb_mode4_design_note_inefficient_4": "This is common in network design to reduce routing tables. The network relies on the 'Longest Prefix Match' rule to handle traffic for any 'holes' that are in use elsewhere.",
    "fb_mode4_step1_desc_main": "First, we list the networks. We see the first <strong>{fixedOctets}</strong> octets are identical.",
    "fb_mode1_step1_title": "1. Identify Requirement (Historical Rule)",
    "fb_mode1_step1_desc_subnets_1": "The requirement is",
    "fb_mode1_step1_desc_subnets_2": "usable subnets. Due to the historical 'Classful' rule, we must reserve the first (Zero) and last (All-Ones) subnets.",
    "fb_mode1_step1_desc_subnets_3": "Actual Calculation:",
    "fb_mode1_step1_desc_hosts_1": "The requirement is",
    "fb_mode1_step1_desc_hosts_2": "usable hosts per subnet.",
    "fb_mode1_step2_title": "2. Calculate Subnet Bits (n) Needed",
    "fb_mode1_step2_desc_subnets_1": "We find the formula",
    "fb_mode1_step2_desc_subnets_2": "(where 'n' is the bits to borrow).",
    "fb_mode1_step2_desc_subnets_3": "We need to borrow",
    "fb_mode1_step2_desc_subnets_4": "bits.",
    "fb_mode1_step2_desc_hosts_1": "We find the formula",
    "fb_mode1_step2_desc_hosts_2": "(where 'H' is host bits).",
    "fb_mode1_step2_desc_hosts_3": "We need to reserve",
    "fb_mode1_step2_desc_hosts_4": "bits for hosts. With a Class C mask (/24) having 8 host bits, we calculate:",
    "fb_mode1_step3_title": "3. Calculate New Subnet Mask",
    "fb_mode1_step3_desc_1": "The default Class C mask is",
    "fb_mode1_step3_desc_2": "We add the bits we borrowed:",
    "fb_mode1_step3_desc_3": "The new mask is",
    "fb_mode1_step3_desc_4": "(or",
    "fb_mode1_step4_title": "4. Calculate Resulting Totals",
    "fb_mode1_step4_desc_1": "Total Subnets Generated:",
    "fb_mode1_step4_desc_2": "Usable Subnets (-2 Rule):",
    "fb_mode1_step4_desc_3": "Host Bits Remaining:",
    "fb_mode1_step4_desc_4": "Usable Hosts per Subnet:",
    "fb_mode1_step4_desc_5": "(The '-2' is for the Network ID and Broadcast address).",
    "subnet_gen_calc_type_summary": "Summarization"
}